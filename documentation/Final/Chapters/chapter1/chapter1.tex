\chapter{Introduction}
Extending java.util.stream with new query operations requires implementation of two distinct iteration protocols:
\begin{itemize}
\item Traversing elements individually (i.e. tryAdvance())
\item Traversing elements in bulk (i.e. foreachRemaining())
\end{itemize}
This incurs in undesired verbosity. In this project we propose a solution - Jayield - which infers the individual element traversal definition from a given bulk traversal method, and thus allows the implementation of new query operations with a single method (e.g. lambda expression).


\section{Motivation}

Java 8 brings with it the java.util.stream API (henceforth named just Stream) which allows us to perform queries fluently on a sequences of data, by providing methods that accept behaviour as parameters, allowing the programmers to express what their intentions are when calling the method.

\newpage
Let us consider the following two classes.
\lstinputlisting[caption={Fruit},label={lst:fruit}]{./Chapters/chapter1/listings/Fruit.java}
\lstinputlisting[caption={Basket},label={lst:basket}]{./Chapters/chapter1/listings/Basket.java}

Listing ~\ref{lst:fruit} specifies the definition of a Fruit and listing ~\ref{lst:basket} makes use of said definition and specifies the fruits inside a basket. Now, lets say we want to know the names of all the fruits inside the basket that have the color orange. In Java 7 and previous versions we would do something like this:

\lstinputlisting[caption={Iterator approach},label={lst:basket-iterator}]{./Chapters/chapter1/listings/withIterator.java}

\newpage
As we can see in, we would attain an iterator and as we iterate over the fruits on the basket we check their color, if it matches our desired color we then write down it's name. Now lets look at how we can do this in Java 8 making use of Streams.

\lstinputlisting[caption={Stream approach},label={lst:basket-stream}]{./Chapters/chapter1/listings/withStream.java}

This approach lets us define our intentions, first we say we are only interested in fruits with the color orange, and that for each fruit that matches that description we want to write down it's name. This approach lets us specify our intentions clearly which in turn makes the code easier to read and understand.

With that said, using just the Stream API Java 8 provides, we soon come to a point  where we would like to create a new operation, to that end Java provides the Spliterator interface which we can implement or the AbstractSpliterator class that we can extend.

\lstinputlisting[caption={Spliterator example},label={lst:spliterator}]{./Chapters/chapter1/listings/Example.java}
In listing ~\ref{lst:spliterator} we show an example of the implementation of a filterOdd operation (line~\ref{line:filterOdd}) which in turn requires an auxiliary class implementing spliterator (i.e. OddFilter, lines~\ref{line:newoddFilter} and~\ref{line:oddFilter}). In this case we extend the AbstractSpliterator instead of implementing the Spliterator interface to reduce the number of methods we're required to implement.

This approach is verbose, and does not benefit from bulk traversing, as stated by the Spliterator documentation, the forEachRemaining\citep{spliterator} method's default implementation should be overridden whenever possible as it just calls tryAdvance until it returns false, in other words, it will traverse element by element instead of the whole sequence. To overcome these shortcomings we will implement a solution that allows the user to define a single way to traverse a sequence and we will generate it's counterpart, i.e. if the user expresses how to traverse a sequence item by item we will generate a function that will allow for bulk traversing and vice-versa.

\section{Query}

A Query represents a sequence of elements supporting sequential operations in Jayield. This class implements all the utility methods with the same name, semantics and behaviour as those provided by Java's Stream. The traversal methods are specified by two distinct interfaces, Advancer which allows the user to express how to traverse a sequence item by item and Traverser that is used to express how to bulk traverse a sequence. Both of these are functional Interfaces and both use a third functional interface to process through elements, Yield. Yield is equivalent to the Java Consumer, however, to reinforce the role of this functional interface as the element generator, it was decided to create a new one.
\begin{lstlisting}[caption={Interfaces},captionpos=b]
interface Traverser <T> { void traverse (Yield <T> yield );}
interface Advancer <T> { boolean tryAdvance (Yield <T> yield );}
interface Yield <T> { void ret(T item );}
\end{lstlisting}

Query provides a way for the user to define new operations through the then function.
\begin{lstlisting}[caption={Traversal function generator},captionpos=b]
<R> Query<R> then(Function<Query<T>, Traverser<R>> next)
\end{lstlisting}
This method has a function parameter "next", which receives the previous (downstream) sequence and returns a new implementation of a traversal function, a Traverser.
\lstinputlisting[caption={Advancer},label={lst:advancer-simple}]{./Chapters/chapter1/listings/Advancer.java}

 The implementation for the Advancer (i.e. the individual traverser) will only be generated if requested to the Advancer interface as it is not always necessary to traverse. To do so we can call one of the two from methods provided in Advancer as shown in the~\ref{lst:advancer-simple} listing.

\newpage
Going back to the filterOdd example, if we wanted to implement it we would do it in one of the following ways.
\begin{lstlisting}[caption={filterOdd using Query and Traverser},captionpos=b]
public class App{
	static <U> Traverser <U> filterOdd (Query<U> prev) {
		return yield -> {
			final boolean [] isOdd = { false };
			prev.traverse(item -> {
				if(isOdd[0]) yield.ret(item);
				isOdd[0] = !isOdd[0];
			});
		};
	}

	public static void main(String[] args) {
		Query.of(1, 2, 3, 4)
            .map(i -> i + 4))
            .then(App::filterOdd)
            .forEach(System.out::println);
	}
}
\end{lstlisting}

\begin{lstlisting}[caption={filterOdd using Advancer},captionpos=b]
public class App{
	static <U> Advancer <U> filterOdd (Advancer<U> prev ) {
		return yield -> {
			if (!prev.tryAdvance(item -> {})) return false;
				return prev.tryAdvance(yield);
		};
	}

	public static void main(String[] args) {
        Query<Integer> query = Query.of(1, 2, 3, 4)
                                  .map(i -> i + 4);
        Advancer<Integer> filterOdd = filterOdd(Advancer.from(query));
        while (filterOdd.tryAdvance(System.out::println));
	}
}
\end{lstlisting}

This approach is less verbose, does not break fluent query invocation and if we call then we will be bulk traversing efficiently without needing to define how to traverse item by item.

\section{Use Case}

When we first started developing this project, it was though that generating an Advancer for every Traverser would be best, this was mainly due to short circuiting operations, meaning, operations that do not traverse the whole sequence, such as the operation limit(int n) that stops once n number of elements have been processed. As we discovered, generating the Advancer is not always necessary, we can short circuit operations through the use of lightweight exceptions, which are exceptions that are not as disruptive to the process as a regular exception. With that said, generating Advancers is still important for operations that require the use of more than one sequence such as zip, which creates a sequence that combines the elements of multiple sequences.

The use case that will be analysed, developed and tested will be the generation of an Advancer from either a Query or a Traverser.

The difficulty with this use case is the fact that a Traverser is used to bulk traverse an entire sequence, meaning it is not (or should not be) prepared to verify if it can advance at each element of the sequence. To do this we will copy the Traverser's code and instrument the required parts to generate a new Advancer. To test if the generated Advancer is working properly we will verify that each call to tryAdvance that succeeds, yields one element and only one element.

\section{Approaches}
To achieve the expected result a pseudo-solution was thought of, assuming one of the following is true:
\begin{itemize}
\item A call to source.traverse(...) is made
\item A call to yield.ret(...) is made
\end{itemize}


Assuming any of these are true, we would generate an Advancer doing the following:
\begin{itemize}
\item Instead of calling source.traverse(...) we would need to call source.tryAdvance(...)
\item When calling yield.ret(...) we would register that an element has been found that meets the criteria.
\item The call to source.tryAdvance(...) is made like so: while(noElementFound \&\& source.tryAdvance(...))
\end{itemize}

So, lets say we have the following definition for a map Traverser:
\begin{lstlisting}[caption={Map Traverser},label={lst:map-traverser},captionpos=b]
<T, R> Traverser<R> map(Query<T> source, Function<T, R> mapper) {
	return yield -> {
    	source.traverse(e -> yield.ret(mapper.apply(e)));
	};
}
\end{lstlisting}

Given the bulk traversal definition of map in listing~\ref{lst:map-traverser}, then the resulting map which implements the individual traversal is shown in listing~\ref{lst:map-advancer}

\begin{lstlisting}[caption={Map Advancer},label={lst:map-advancer},captionpos=b]
<T, R> Advancer<R> map(Query<T> source, Function<T, R> mapper) {
	(*@\textcolor{blue}{boolean[] noElementFound = new boolean[] \{true\};}@*)
	return yield -> {
		(*@\textcolor{blue}{noElementFound[0] = true;}@*)
		while(noElementFound[0] && source.tryAdvance(e -> {
				yield.ret(mapper.apply(e)));
				(*@\textcolor{blue}{noElementFound[0] = false;}@*)
			});
		(*@\textcolor{blue}{return noElementFound[0] == false;}@*)
	};
}
\end{lstlisting}

With that said, there are corner cases that are not so easily mapped as is the case of the flatMap operation which traverses over multiple sequences, these cases need a different approach.

Nevertheless, following the suggested approach we will need to generate code at runtime, to do this we will use ASM, a library for java bytecode manipulation at runtime. In order to read the bytecode via ASM we first need to give it (via the ClassReader) the actual bytecode of the Traverser. The problem is, if the Traverser was generated using a lambda function, that the lambda's class is generated at runtime via the LambdaMetaFactory class and therefore the normal method of getting the bytecode does not work, aside from that we also needed to get any fields the Traverser's class may have, in the case of the lambda, they would be captured arguments.

To solve this issue, two paths were found\citep{stackoverflowlambdacode}, the use of SerializedLambda\citep{serializedlambda} or the use of another library called Bytebuddy.

\section{SerializedLambda}

If the lambda we are trying to read implements an interface that extends Serializable, the LambdaMetaFactory class will generate a private method called 
"writeReplace" which provides an instance of the class SerializedLambda. This instance can be used to retrieve both the actual static method that was generated for this lambda as well as get the captured arguments. Being able to reach the lambda's method would allowed us to instrument it, to do so, we used a custom ClassVisitor that copies the original declaring class of the lambda as well as making some changes along the way, such as:
\begin{itemize}
\item The name of the class would now be the name of the lambda's method.
\item Each call to a method on the declared class would now be a call to the generated class, due to calls to private methods.
\item The return type of the lambda's method would now be boolean instead of void, to be coherent with the Advancer Interface.
\item The lambda's method would now call tryAdvance instead of traverse and return the result of tryAdvance as well.
\end{itemize}

To obtain an Advancer out of the generated class all we would need to do now would be:
\begin{itemize}
\item Retrieve the original lambda's captured arguments
\item Retrieve the generated method from the new class
\item Apply the approach defined above.
\end{itemize}

Which would result in something like this:
\begin{lstlisting}[caption={Generated Advancer},captionpos=b]
final BoolBox elementFound = new BoolBox();
Method generatedTryAdvance = getTryAdvance(...);
Advancer generated =  y -> {
	elementFound.reset();
	Yield<R> wrapper = wr -> {
		y.ret(wr);
		elementFound.set();
	};
	arguments[arguments.length - 1] = wrapper;
	while(elementFound.isFalse() && (Boolean) generatedTryAdvance.invoke(newClass, arguments));
	return elementFound.isTrue();
};
\end{lstlisting}

This solution makes use of a wrapper over the yield received as parameter to register when an element is found, this wrapper is then provided as the last argument in an argument array for the generated method, with the first parameters being those captured by the lambda. 

A downside to this approach is that it would mean the Traverser functional interface would need to extend Serializable, which would be otherwise unnecessary.


\section{Bytebuddy}

This approach was not as thoroughly investigated as the previous one, with that said, the main difference between the two is the way the class of the lambda and the arguments are obtained. To use this approach we need to add the ByteBuddyAgent to the class path and to call the install static method it provides to get a hold of it's implementation of the Instrumentation Interface. We are then able to obtain the class of the Traverser we are trying to instrument, and this is where the main difference resides, we get the class directly not a method like in the SerializedLambda approach. This class has the fields, that the lambda captured, and an implementation of the traverse method. Which makes it seem like a similar approach to the SerializedLambda is possible, we would just make use of a custom ClassVisitor that would generate an Advancer from the Traverser implementation and then return it.
